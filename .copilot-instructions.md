# Copilot Instructions for p3-model

## Project Overview
p3-model is a C++ object model library for podcast production and publishing (P3) under the ultralove organization. This library provides comprehensive modeling capabilities for podcast workflows, content management, and publishing processes.

## Development Guidelines

### Language & Framework
- Primary language: C/C++
- Build system: CMake
- License: MIT License

### Code Style & Standards
- Follow modern C++ best practices (C++23 standard)
- Use RAII principles for resource management
- Prefer smart pointers over raw pointers
- Use const-correctness
- All function input parameters should be const (e.g., `void SetTitle(const std::string& title)`)
- All functions that return class data without modification should be const (e.g., `std::string GetTitle() const`)
- All destructors should be virtual (even when deleted)
- All abstract/interface classes should have a protected virtual destructor
- Always use modern C++ line comments (//) even for multi-line comments
- This style provides extra safety and consistency throughout the P3 model library codebase.
- Follow consistent naming conventions:
  - Types (classes, structs, enums): Upper PascalCase (e.g., `Episode`, `SharedObject`)
  - Functions/methods: Upper PascalCase (e.g., `GetTitle`, `SetDuration`)
  - Variables and function parameters: camelCase (e.g., `bufferSize`, `episodeCount`)
  - Member variables: camelCase with underscore postfix (e.g., `dataSize_`, `title_`)
  - Constants: UPPER_SNAKE_CASE (e.g., `MAX_EPISODE_LENGTH`)
- Remove redundant prefixes from class names (e.g., use `Model` instead of `P3Model`)

### Project Structure
- All source files must be in the `ultralove::p3::model` namespace
- Always use single-line namespace declarations (e.g., `namespace ultralove::p3::model {`)
- Keep source files organized in logical directories (e.g., `src/`, `include/`)
- Header files must use `.h` extension (not .hpp)
- Implementation files use `.cpp` extension
- File names should match the class name they contain in Upper PascalCase
  - Example: `Episode` class → `Episode.h` and `Episode.cpp`
  - Example: `SharedObject` class → `SharedObject.h` and `SharedObject.cpp`
- Use traditional include guards in all headers with format: `#ifndef __P3_FILENAME_H_INCL__`
  - Example: `#ifndef __P3_MODEL_H_INCL__` for p3-model.h
  - For multi-word filenames, convert PascalCase to UPPER_SNAKE_CASE
  - Example: `#ifndef __P3_SHARED_OBJECT_H_INCL__` for SharedObject.h
  - Convert hyphens to underscores in filenames
  - Always include project name (P3) and file name in uppercase
- All header files must specify 8-byte alignment using `#pragma pack(push, 8)` at the beginning and `#pragma pack(pop)` at the end
- Maintain clear separation between public API and implementation details
- Organize models by domain areas (e.g., content, production, publishing, metadata)

### CMake Guidelines
- Use modern CMake practices (4.0+)
- **ALWAYS configure CMake with: `cmake -G Ninja -B _build`**
- **ALWAYS build with: `cmake --build _build`**
- Always use Ninja generator for builds (`cmake -G Ninja -B _build`)
- Use version.in file for version management instead of hardcoding versions
- Organize CMakeLists.txt files hierarchically
- Use target-based approach with `target_*` commands
- Set appropriate compiler flags and warnings
- Default to Debug build type for development
- Create cmake/ directory for package config templates (e.g., `cmake/p3-model-config.cmake.in`)

### Documentation
- Document public APIs with clear comments
- Use detailed Doxygen-style comments in header files with traditional form:
  - Use /// for Doxygen comments
  - Use \param for parameters, \return for return values, \brief for brief descriptions
  - Example: /// \brief Sets the episode title
  ///         \param title The new title for the episode
- Use Graphviz DOT for class diagrams and dependency diagrams:
  - Use @dot...@enddot blocks for custom graphs
  - Good for showing data flow, component relationships, and class structures
  - Use professional styling with white backgrounds and clear fonts
  - Example: @dot digraph example { ... } @enddot
- **UML Diagram Guidelines**: Treat String, Guid, Timestamp, Timespan as primitive types
  - These should appear as attributes in class diagrams, not as separate class boxes
  - Focus diagrams on domain model relationships, not implementation utility types
  - Keep diagrams clean by treating runtime utilities as built-in primitives
- Implementation files (.cpp) should use inline documentation with // comments for logic explanation
- Keep README.md updated with build instructions and usage examples
- Document any dependencies and requirements
- **CRITICAL: Always verify documentation against actual implementation**
  - README.md must show real API patterns, not fictional functions
  - Use actual struct member names and types from header files
  - Integration examples must use real function signatures and member access patterns
  - All type names must match implementation (e.g., `Guid` not `GUID`)

### Testing
- Write unit tests for core functionality
- Consider using a testing framework like Google Test or Catch2
- Maintain good test coverage

### Git Workflow
- Use meaningful commit messages following conventional commits format
- Keep commits atomic and focused
- Use feature branches for development
- **CRITICAL RULE: NEVER commit automatically without explicit user instruction**
- **ALWAYS let the user decide when and how to commit changes**
- When asked to commit changes:
  1. Stage all latest changes with `git add .`
  2. Write detailed but concise commit message using conventional commits
  3. Commit with `git commit -m "message"`
- Conventional commit format: `type(scope): description`
  - Types: feat, fix, docs, style, refactor, test, chore
  - Example: `feat(core): add initial model framework structure`

## Build Instructions
Current build process:
1. Configure with CMake using Ninja generator: `cmake -G Ninja -B _build`
2. Build the project: `cmake --build _build`
3. The build generates `libp3-model.a` static library

Documentation generation (requires Doxygen and LaTeX):
1. Generate LaTeX documentation: `cmake --build _build --target docs`
2. Build PDF from LaTeX: `cmake --build _build --target docs-pdf`
3. PDF output: `_build/docs/latex/p3-model.pdf`

Version management:
- Version is stored in `version.in` file (currently 0.1.0)
- CMakeLists.txt reads version from this file automatically
- Update version by editing the `version.in` file

Build artifacts:
- Static library: `_build/libp3-model.a`
- CMake package files for integration with other projects
- Documentation: `_build/docs/latex/p3-model.pdf` (when Doxygen is available)

## Project Status and Documentation

### Current Implementation Status
- **Core Library Structure**: Complete with Model struct as main entry point
- **C++ Object Model**: Complete implementation with 22 structs covering entire podcast domain
  - Base classes: Fabric (entity base), Asset (media base)
  - Content hierarchy: Podcast → Season → Episode with full relationship management
  - People system: Contributor, ContributorPresence, Contribution with role management
  - Publisher workflow: Publisher entity with ownership tracking
  - Annotation system: Tag hierarchy (ChapterTag, LocationTag, TranscriptTag)
  - Media assets: Picture and Enclosure with format type management
  - Comprehensive enumerations: 6 enum types with utility functions
- **Runtime Utilities**: Guid, String, TimeSpan, TimeStamp primitive types (basic implementations)
- **Build System**: Modern CMake configuration with Ninja support, compiles to libp3-model.a
- **Documentation System**: Doxygen integration with Graphviz support, comprehensive API docs
- **Version Management**: Automated through version.in file (currently 0.1.0)
- **Demo Program**: Working demonstration of struct instantiation and basic operations
- **README.md**: Comprehensive GitHub repository documentation complete

### Documentation Standards
- **README.md**: Comprehensive repository documentation following GitHub best practices
  - No emojis policy enforced
  - Includes quick start guide, architecture overview, code standards
  - Contributing guidelines with conventional commit format
  - Integration examples and build instructions
  - Professional tone with clear project structure visualization
- **API Documentation**: Generated with Doxygen
- **UML Diagrams**: Embedded PlantUML diagrams in headers using monochrome theme
- **Code Comments**: Inline documentation with // comments for implementation logic

## Dependencies
Current dependencies:
- CMake 4.0+ (minimum required version)
- C++23 compatible compiler (tested with AppleClang 17.0.0)
- Ninja build system (preferred generator)

Optional dependencies for documentation:
- Doxygen (for generating API documentation)
- LaTeX distribution (for PDF documentation generation)
- Graphviz dot (for dependency graphs and UML diagrams)

No external libraries currently required.

## Architecture Notes
This library models the complete podcast production and publishing domain with a fully implemented C++ object model. The implementation includes:

### Implemented Domain Models
- **Content Models**: Podcast, Season, Episode with complete hierarchy and relationships
- **People Models**: Contributor, ContributorPresence, Contribution with role-based access
- **Production Models**: Tag system (ChapterTag, LocationTag, TranscriptTag) for content annotation
- **Publishing Models**: Publisher entity with ownership and URI management
- **Asset Models**: Picture and Enclosure classes for media file management
- **Metadata Models**: Comprehensive enumeration system and TagReference for external linking
- **Base Infrastructure**: Fabric base class providing common entity functionality (ID, timestamps, comments)

### Implementation Architecture
All models are designed with:
- **Inheritance**: Proper base class hierarchy with Fabric providing common functionality
- **Composition**: Complex objects contain collections of related entities
- **Encapsulation**: Private member variables with public getter/setter interfaces
- **Polymorphism**: Virtual methods and proper destructors for safe inheritance
- **Memory Management**: RAII principles with proper resource handling
- **Type Safety**: Strong typing with comprehensive enumeration system

### Technical Design Patterns
- **Entity Base Pattern**: Fabric class provides common functionality (GUID, timestamps, comments)
- **Collection Management**: STL containers for one-to-many relationships
- **Forward Declarations**: Minimize compilation dependencies
- **Const Correctness**: Input parameters and non-modifying methods properly const-qualified
- **Namespace Organization**: Clean separation under ultralove::p3::model
- **Documentation Integration**: Graphviz diagrams embedded in header files

### Future Extension Points
The current implementation provides hooks for:
- **Serialization/Deserialization**: Structure ready for JSON/XML export
- **Validation**: Framework ready for business rule enforcement
- **Query System**: Collection methods support search and filtering
- **Event System**: Virtual methods ready for observer pattern implementation
- **Persistence**: Database integration points identified
- **API Integration**: External service integration through URI and reference systems

### PlantUML Styling
- Use the monochrome theme located at `docs/plantuml-monochrome.puml`
- Include the theme in all PlantUML diagrams with: `!include docs/plantuml-monochrome.puml`
- This ensures consistent black-and-white professional styling across all documentation
- The theme defines pure white background with black text and borders for all diagram elements
- Example usage in header files:
```cpp
/*!
 * @startuml
 * !include docs/plantuml-monochrome.puml
 * class Model {
 *   +GetVersion() : string
 *   +Initialize() : bool
 * }
 * @enduml
 */
```

## Recent Changes and Updates

### August 21, 2025
- **Script Cleanup**: Removed unnecessary `scripts/add-times-font.sh` file (empty and no longer needed)
- **UML Diagram Simplification**: Updated documentation to treat runtime utilities as primitive types
  - String, Guid, Timestamp, Timespan now treated as built-in primitives in diagrams
  - Removed emphasis on these as separate "foundation classes" or "utility classes"
  - UML diagrams focus on domain model relationships rather than implementation details
  - Updated language throughout documentation to reflect primitive type approach
- **README.md Synchronization with Actual Implementation**: Fixed critical discrepancies between documentation and code
  - **GUID → Guid Correction**: Updated all references from incorrect `GUID` to actual `Guid` type name throughout README.md
  - **API Documentation Correction**: Replaced fictional `Get*()` function calls with actual public member access patterns
  - **Fabric Class Documentation**: Updated to show real implementation with direct member access (`id`, `typeId`, `creationDate`, etc.)
  - **Podcast Class Documentation**: Corrected to show actual members (`title`, `subtitle`, `description`, `publisher`, `coverArt`, `seasons`, etc.)
  - **Season Class Documentation**: Updated to reflect real implementation (`seasonNumber`, `title`, `description`, `episodes`, etc.)
  - **Episode Class Documentation**: Fixed to show actual structure (`episodeNumber`, `title`, `type`, `duration`, `enclosures`, etc.)
  - **Contributor Class Documentation**: Corrected to show real members (`name`, `email`, `url`, `role`, `bio`, `image`, `presence`)
  - **Integration Example Enhancement**: Updated example code to show real API usage patterns with direct member access
  - **Runtime Namespace Correction**: All references now correctly use `ultralove::p3::runtime` namespace
- **Documentation Standards Update**: Emphasized importance of keeping documentation synchronized with actual implementation
  - Added requirement to verify API documentation against actual header files
  - Established pattern of showing real struct member variables instead of fictional getter functions
  - README.md now accurately reflects the value-semantics design with direct member access
- **Enumeration Refactoring and Simplification**: Separated enumerations into individual files and simplified structure
  - Created 6 separate enumeration files: `modelcontributorrole.h`, `modelepisodetype.h`, `modelcontributorpresencetype.h`, `modeltagreferencetype.h`, `modelpicturetype.h`, `modelenclosuretype.h`
  - Deleted `modelenumerations.h` aggregate file as it was no longer needed after modular refactoring
  - Removed `EnumUtils` namespace and ToString functions from all enumeration files for cleaner, simpler design
  - Removed unnecessary `#include "runtimestring.h"` dependencies from enumeration files
  - Updated `model.h` to include all individual enumeration files directly
  - Modified consuming files (`modelpicture.h`, `modelenclosure.h`, `modelepisode.h`) to include specific enumerations they need
  - Maintains clean compilation dependencies and follows single responsibility principle
  - Each enumeration file is now self-contained with minimal dependencies
  - Build system continues to work perfectly with simplified enumeration structure
- **Diagram Documentation Update**: Removed DOT diagram from modelfabric.h
  - Cleaned up Graphviz @dot...@enddot blocks from base Fabric class documentation
  - Simplified documentation while maintaining clear API descriptions
  - Part of ongoing documentation refinement on feature/mermaid-diagram branch
- **Complete C++ Struct Implementation**: Created comprehensive object model from UML diagram
  - Implemented 22 C++ structs covering the entire podcast production and publishing domain
  - Created proper inheritance hierarchy with Fabric base class for all entities
  - Added 6 comprehensive enumerations: ContributorRole, EpisodeType, ContributorPresenceType, TagReferenceType, PictureType, EnclosureType
  - Implemented core content classes: Podcast, Season, Episode with full relationship management
  - Added contributor system: Contributor, ContributorPresence, Contribution for people and role management
  - Created tag system: Tag, ChapterTag, LocationTag, TranscriptTag for content annotation
  - Added asset management: Asset, Picture, Enclosure for digital media handling
  - Implemented Publisher class for content publishing workflow
- **Source File Organization**: Structured implementation across logical modules
  - Individual enumeration files: `modelcontributorrole.h`, `modelepisodetype.h`, `modelcontributorpresencetype.h`, `modeltagreferencetype.h`, `modelpicturetype.h`, `modelenclosuretype.h`
  - `modelfabric.h`: Base class providing common functionality for all entities
  - `modelasset.h`: Digital asset management classes
  - `modeltag.h`: Content annotation and metadata system
  - `modelcontributor.h`: People and roles in podcast production
  - `modelpublisher.h`: Publishing entity management
  - `modelpodcast.h`: Core podcast content hierarchy
  - Updated main `model.h` to include all new headers
- **Build System Integration**: Enhanced CMake configuration
  - Added all new source files to library compilation
  - Updated header list for IDE support and installation
  - Library successfully builds as `libp3-model.a`
  - Created working demo program validating struct instantiation and basic operations
- **Code Standards Compliance**: All implementations follow established guidelines
  - Proper namespace organization: `ultralove::p3::model`
  - Consistent naming conventions: PascalCase types, camelCase variables with underscore postfix
  - Traditional include guards with `__P3_FILENAME_H_INCL__` format
  - 8-byte memory alignment with pragma pack directives
  - Comprehensive Doxygen documentation with @dot Graphviz diagrams
  - Modern C++ practices: const correctness, virtual destructors, RAII principles

### August 20, 2025
- **Documentation Build System Update**: Reverted to Graphviz for better diagram quality
  - Removed PlantUML dependency and JAR detection from CMakeLists.txt
  - Replaced all PlantUML diagrams with professional Graphviz DOT diagrams
  - Re-enabled Graphviz integration with DOXYGEN_HAVE_DOT YES
  - Updated all header files to use @dot...@enddot syntax instead of @startuml...@enduml
  - Improved diagram aesthetics with professional styling and clean layouts
- **README.md Enhancement**: Added comprehensive GitHub repository documentation
  - Complete project overview with feature descriptions
  - Quick start guide with step-by-step build instructions
  - Architecture documentation and code standards reference
  - Contributing guidelines with conventional commit format
  - Version management, support information, and development roadmap
  - Professional formatting without emojis, following markdown best practices
  - Integration examples for library usage
- **Git Workflow**: Implemented conventional commit standards
  - Commit: `f1a0762` - docs(readme): add comprehensive README.md for GitHub repository
  - 215 insertions, 1 deletion in README.md file

### Development Notes
- **Current Implementation Status**: Core object model is complete with 22 working C++ structs
- **Runtime Dependencies**: Struct implementations use placeholder runtime classes (String, GUID, Timestamp)
- **Next Development Phase**: Focus on completing runtime utility implementations
- All future documentation should maintain consistency with README.md standards
- Continue following the no-emoji policy for all project documentation
- Maintain professional tone across all user-facing documentation
- Update README.md as new features are implemented and architecture evolves

---
*Last updated: August 21, 2025*
*Recent changes: Synchronized README.md with actual implementation - corrected GUID→Guid, removed fictional Get*() functions, updated all API examples to show real struct member access patterns*
